<?php
// $Id: user_backreference.module,v 1.1.2.1 2010/05/28 12:51:00 joachim Exp $
/**
 * @file user_backreference.module
 * Allows users to edit on their account page the references to their account that exist on nodes.
 *
 * WARNING: this is a half-baked module: it has been developed for a specific project's needs,
 * and is production-ready for that set of requirements, but has considerable gaps.
 * As such, it still requires:
 *  - an admin UI
 *  - support for more than one field
 *  - support for user access considerations
 * It is released in the hope that it will be useful, and that others may be able
 * to take it forward and fill in the missing pieces.
 */

/**
 * Get field definitions for all the user_ref fields we work with.
 *
 * @TODO: field name is hardcoded. Replace this with settings and an admin UI.
 */
function user_backreference_get_fields() {
  // HARDCODED field name. Put your own here! Or better stillm write a patch for an admin UI! ;)
  $field_names = array('field_members');
  
  foreach ($field_names as $field_name) {
    // @todo: check the $field's reverse_link value and only act if this is TRUE.
    $fields[$field_name] = content_fields($field_name);
  }
  
  return $fields;
}

/**
 * Implementation of hook_perm().
 */
function user_backreference_perm() {
  return array(
    // @TODO: make these work. ;)
    'reference self on own content', 
    'reference self on editable content', 
    'reference self on any content',
  );
}

/**
 * Implementation of hook_help().
 */
function user_backreference_help($path, $arg) {
  switch ($path) {
    case 'admin/help#user_backreference':
      return t('TODO: Create admin help text.');
    // OPTIONAL: Add additional cases for other paths that should display help text.
  }
}

/**
 * Implementation of hook_menu().
 */
function user_backreference_menu() { 
  // This is the minimum information you can provide for a menu item.
  /*
  $items['TODO: Enter path'] = array(
    'title' => 'TODO: Enter menu item title',
    'page callback' => 'TODO: Enter callback function',
    'access arguments' => array('TODO: Enter user permissions'),
  );
  // more complex menu item
  $items['TODO: Enter path'] = array(
    'title' => 'TODO: Enter menu item title',
    'description' => 'TODO: Enter description',
    'page callback' => 'TODO: Enter callback function',
    'page arguments' => '', // An array of arguments to pass to the page callback function. Integer values pass the corresponding URL component.
    'access callback' => '', // defaults to user_access()
    'access arguments' => array('TODO: Enter user permissions'),
    'weight' => 0,
    'type' => MENU_NORMAL_ITEM, // One of MENU_NORMAL_ITEM / MENU_CALLBACK / MENU_SUGGESTED_ITEM / MENU_LOCAL_TASK / MENU_DEFAULT_LOCAL_TASK
    'menu_name' => '', // Menu to place this item in.
    'title callback' => '', // Function to generate the title, defaults to t(). 
    'title arguments' => '', // Arguments to send to t() or your custom callback. 
  );
  // OPTIONAL: Fill in additional static menu items
  */

  return $items;
}

/**
 * Implementation of hook_form_alter().
 */
function user_backreference_form_alter(&$form, $form_state, $form_id) {

}

/**
 * Implementation of hook_user().
 */
function user_backreference_user($op, &$edit, &$account, $category = NULL) {
  switch ($op) {
    // The user account registration form is about to be displayed. 
    // The module should present the form elements it wishes to inject into the form.
    case 'register':
      return user_backreference_form_profile($edit, $account, $category, TRUE);

    // The user account edit form is about to be displayed.
    // The module should present the form elements it wishes to inject into the form.
    case 'form':
      return user_backreference_form_profile($edit, $account, $category);

    // The user account is being added. 
    // The module should save its custom additions to the user object into the 
    // database and set the saved fields to NULL in $edit.
    case 'insert':
      user_backreference_save_profile($edit, $account, $category, TRUE);
      break;

    // The user account is being changed. 
    // The module should save its custom additions to the user object into the 
    // database and set the saved fields to NULL in $edit.
    // TODO: This method doesn't seem to work because it's stored on a page generated by profile.module
    case 'update':
      return user_backreference_save_profile($edit, $account, $category);

  }
}

/**
 * Helper for hook_user 'form' and 'register': add fields to the user account form.
 */
function user_backreference_form_profile($edit, $account, $category, $register = FALSE) {
  if ($register == FALSE && $category != 'account') {
    return;
  }

  $form['user_backreference'] = array(
    '#type' => 'fieldset',
    '#title' => t('Related content'),
  );
  
  $form['user_backreference_fields'] = array(
    '#type' => 'value',
    '#value' => array(),
  );

  $fields = user_backreference_get_fields();
  
  // @todo: what happens with a field on more than one type?
  // not our problem for current project, but should be addresse for a full release.
  foreach ($fields as $field_name => $field) {
    $types[] = $field['type_name'];
    // Add a 'None' option for each field.
    // @todo: allow this to be a required value?
    $options[$field['type_name']] = array('0' => '<None>');
  }

  // Retrieve all nodes in a single query.
  // Note that $node is not a fully-loaded node object, just the data in the {node} table.
  $placeholders = implode(', ', array_fill(0, count($types), "'%s'"));
  // @todo: figure out how the hell db_rewrite_sql() is meant to be used.
  $result = db_query("SELECT n.* FROM {node} n WHERE n.status = 1 AND n.type IN ($placeholders)", $types);
  while ($node = db_fetch_object($result)) {
    $nodes[$node->type][$node->nid] = $node;
    $options[$node->type][$node->nid] = check_plain($node->title);
  }
  
  foreach ($fields as $field_name => $field) {
    // Add the field name to the array.
    $form['user_backreference_fields']['#value'][] = $field_name;

    // Get CCK's database info for this field and hence table and field names.
    $db_info = content_database_info($field);
    $table = $db_info['table'];
    $column = $db_info['table']['columns']['uid']['column'];
    
    $result = db_query("SELECT nid FROM content_type_content_punt WHERE" . $column . "= %d", $account->uid);
    while ($nid = db_result($result)) {
      $default_values[$nid] = $nid;
    }
    
    $form['user_backreference'][$field_name] = array(
      '#title' => check_plain(node_get_types('name', $field['type_name'])),
      '#description' => t('Select content to relate your account to.'),
      '#type' => 'select',
      '#multiple' => TRUE,
      '#options' => $options[$field['type_name']],
      '#default_value' => $default_values,
    );
    
    // Store the nids the user had the option of choosing from to prevent 
    // clobbering issues when saving the data in user_backreference_save_profile().
    $form['available_nids'] = array(
      '#type' => 'value',
      '#value' => $options,
    );
  }
  
  //dsm($form);

  return $form;
}

/**
 * Helper for hook_user 'insert' and 'update': save our form data.
 */
function user_backreference_save_profile($edit, $account, $category) {
   // Check for the presence of our hidden value set in user_backreference_form_profile().
   // If it is not set, then we have come here from something that is not a
   // user edit form, eg a user admin operation such as 'block user', and
   // have no data to save. Leave now!
   if (!isset($edit['user_backreference_fields'])) {
     return;
   }

  //dsm($edit);
  
  // @warning
  // could there be some godawful clashing issues if another user is editing the same node?
  
  $fields = user_backreference_get_fields();
  
  foreach ($fields as $field_name => $field) {
    // Get CCK's database info for this field and hence table and field names.
    $db_info = content_database_info($field);
    $table = $db_info['table'];
    $column = $db_info['columns']['uid']['column'];

    // Clear the current data for this user.
    // @todo: use $edit['available_nids'] to only delete the nids that the user
    // had access to (and so could deselect), and avoid clobbering any that they
    // could not depending on permissions, eg nodes they can't edit.
    // WARNING: this is a reason this module is not ready for general release!
    // YOUR DATA WILL GET CLOBBERED!
    // This will leave gaps in the deltas for each node, but CCK appears to not be unduly bothered by this.
    db_query("DELETE FROM {$table} WHERE $column = %d", $account->uid);
    
    // Just a litle bit of help to allow other modules to form_alter this to a single value... ;)
    if (!is_array($edit[$field_name])) {
      $edit[$field_name] = array($edit[$field_name]);
    }
    // Filter out 'None'
    $edit[$field_name] = array_filter($edit[$field_name]);
    
    // Because of various data issues such as the vid and delta, we have to do this
    // separately for each nid.
    // @todo: please post a patch! ;)
    foreach ($edit[$field_name] as $nid) {
      $max_delta = db_result(db_query("SELECT MAX(delta) FROM {$table} WHERE nid = %d", $nid));
      $new_delta = $max_delta + 1;
      
      // This coud probably be done with an INSERT...SELECT query. 
      // @todo: please post a patch ;)
      $vid = db_result(db_query("SELECT vid FROM {node} WHERE nid = %d", $nid));
      
      db_query("INSERT INTO {$table} (vid, nid, delta, $column) VALUES (%d, %d, %d, %d)", array(
        $vid, $nid, $new_delta, $account->uid,
      ));
    }
    
    // Remove our key from the $edit array so its data doesn't go clutter the
    // {users}.data column in the database.
    // @todo: not sure this is working, but it's pretty much cosmetic.
    unset($edit[$field_name]);
  }
  
  // Flush caches so nodes notice the change.
  cache_clear_all('*', 'cache_content', TRUE);
  cache_clear_all();
}
